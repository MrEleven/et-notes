<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="D:/__css/github.css" type="text/css" />
</head>
<body>
<h1 id="第-9-章-协同程序">第 9 章 协同程序</h1>
<p>协同程序与线程类似。从概念上讲，线程与协同程序主要的区别在于，一个多线程程序可以同时运行几个线程，而协同程序却需要批次协作的运行。即，一个具有多个协同程序的程序在任意时刻任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显式地要求挂起时，它的执行才会暂停。</p>
<h2 id="协同程序基础">9.1 协同程序基础</h2>
<p>协同程序状态</p>
<ul>
<li>挂起 suspended</li>
<li>运行 running</li>
<li>死亡 dead</li>
<li>正常 normal</li>
</ul>
<p>当创建一个协同程序时，它处于<code>挂起状态</code>。</p>
<ul>
<li>可以通过<code>coroutine.status()</code>来检查状态。</li>
<li>通过<code>coroutine.resume()</code>启动一个协同程序的执行。（在保护模式下运行）</li>
<li><code>coroutine.yield()</code>挂起一个正在运行的协同程序</li>
</ul>
<p>当一个协同程序A唤醒一个协同程序B时，A就处于正常状态，因为A既不是挂起，也不是运行状态。（B在运行）</p>
<p>可以通过一对resume-yield交换数据。第一次调用resume时并没有对应的yield等待，因此所有传递给resume的额外参数都将视为协同程序主函数的参数</p>
<p>lua提供的是一种&quot;非对此的协同程序&quot;。lua提供了两个函数来控制协同程序的执行，一个用于挂起，另一个用于恢复执行。而对称的协同程序，只有一个函数用于转让协同程序之间的执行权</p>
<p>一个协同程序只能在它没有调用其他函数时才可以挂起执行，即只有协同程序的主函数才能调用类似于yield这样的函数。</p>
<p>lua提供了完整的非对称的协同程序</p>
<h2 id="以协同程序实现迭代器">9.3 以协同程序实现迭代器</h2>
<p>coroutine.wrap() 创建了一个新的协同程序，返回一个函数，调用该函数使唤醒一次协同程序，和resume相比，该函数调用不会返回错误代码，遇到错误会返回错误。</p>
<h2 id="非抢先试的多线程">9.4 非抢先试的多线程</h2>
<ul>
<li>LuaSocket</li>
<li>select</li>
</ul>
</body>
</html>
